// J2.L.P0006 - My Text Editor (MTE)

import com.ozten.font.JFontChooser;
import java.awt.Font;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.event.UndoableEditEvent;
import javax.swing.event.UndoableEditListener;
import javax.swing.undo.CannotRedoException;
import javax.swing.undo.CannotUndoException;
import javax.swing.undo.UndoManager;

// Cái Find và Font cô làm mẫu, mình thêm cái Replace, Save/SaveAs, Exit, Undo với Redo

/**
 *
 * @author SE130460
 */
public class MyTextEditor extends javax.swing.JFrame
{   
    UndoManager manager = new UndoManager();
    JFileChooser fc = new JFileChooser();
    String memory = "";     // Nội dung txtContent
//    boolean save = true;    // Biến để check xem có lưu file hay ko   // Ko dùng đến
    File oldFile;   // File đã đc lưu và có tên trên frame's title
    
    public MyTextEditor()
    {
        initComponents();
        this.setLocationRelativeTo(null);   // Frame nằm giữa màn hình
        // updateBtnStatus();
        mnUndo.setEnabled(false);
        mnRedo.setEnabled(false);
        txtContent.getDocument().addUndoableEditListener(new UndoableEditListener() {
            @Override
            public void undoableEditHappened(UndoableEditEvent e)
            {
                manager.addEdit(e.getEdit());
                updateUndoRedoBtn();
            }
        });
        fc.setAcceptAllFileFilterUsed(false);   // Chỉ cho phép mỗi .txt thôi, tất cả kiểu khác đều ko cho
        fc.setFileFilter(new FileTypeFilter(".txt", "Text Documents"));
        // Bài này chỉ yêu cầu lưu file .txt, ko nhận các loại file khác
    }
    
//    private void updateBtnStatus()
//    {
        // Ban đầu khi mới mở
//        mnSave.setEnabled(false);
//        mnSaveAs.setEnabled(false);
//        mnSelectAll.setEnabled(false);
//        mnCut.setEnabled(false);
//        mnCopy.setEnabled(false);
//        mnPaste.setEnabled(false);
//        mnUndo.setEnabled(false);
//        mnRedo.setEnabled(false);
//        mnFind.setEnabled(false);
//        mnReplace.setEnabled(false);
        
//        if (!txtContent.getText().equals(""))
//        {
//            // Tôi nghĩ nên check trong từng btn, ko nên gộp chung thế này vì cái
//            // này chỉ chạy 1 lần duy nhất ban đầu khi vừa mở, ko check đc thay đổi
//            mnSave.setEnabled(true);
//            mnSaveAs.setEnabled(true);
//            mnSelectAll.setEnabled(true);
//            mnCut.setEnabled(true);
//            mnCopy.setEnabled(true);
//            mnPaste.setEnabled(true);
//            mnUndo.setEnabled(true);
//            mnRedo.setEnabled(true);
//            mnFind.setEnabled(true);
//            mnReplace.setEnabled(true);
//        }
//    }
    
    private void updateUndoRedoBtn()
    {
//        mnUndo.setText(manager.getUndoPresentationName());
//        mnRedo.setText(manager.getRedoPresentationName());
        mnUndo.setEnabled(manager.canUndo());   // Nếu ko còn gì nữa thì ko undo tiếp đc
        mnRedo.setEnabled(manager.canRedo());   // Nếu redo hết cỡ rồi thì ẩn nút đó luôn 
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        txtContent = new javax.swing.JTextArea();
        jMenuBar1 = new javax.swing.JMenuBar();
        mnFile = new javax.swing.JMenu();
        mnNew = new javax.swing.JMenuItem();
        mnOpen = new javax.swing.JMenuItem();
        mnSave = new javax.swing.JMenuItem();
        mnSaveAs = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        mnExit = new javax.swing.JMenuItem();
        mnEdit = new javax.swing.JMenu();
        mnSelectAll = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        mnCut = new javax.swing.JMenuItem();
        mnCopy = new javax.swing.JMenuItem();
        mnPaste = new javax.swing.JMenuItem();
        jSeparator3 = new javax.swing.JPopupMenu.Separator();
        mnUndo = new javax.swing.JMenuItem();
        mnRedo = new javax.swing.JMenuItem();
        jSeparator4 = new javax.swing.JPopupMenu.Separator();
        mnFind = new javax.swing.JMenuItem();
        mnReplace = new javax.swing.JMenuItem();
        mnFont = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setFocusTraversalPolicyProvider(true);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        txtContent.setColumns(20);
        txtContent.setRows(5);
        jScrollPane1.setViewportView(txtContent);

        mnFile.setText("File");

        mnNew.setText("New");
        mnNew.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnNewActionPerformed(evt);
            }
        });
        mnFile.add(mnNew);

        mnOpen.setText("Open");
        mnOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnOpenActionPerformed(evt);
            }
        });
        mnFile.add(mnOpen);

        mnSave.setText("Save");
        mnSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnSaveActionPerformed(evt);
            }
        });
        mnFile.add(mnSave);

        mnSaveAs.setText("Save as");
        mnSaveAs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnSaveAsActionPerformed(evt);
            }
        });
        mnFile.add(mnSaveAs);
        mnFile.add(jSeparator1);

        mnExit.setText("Exit");
        mnExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnExitActionPerformed(evt);
            }
        });
        mnFile.add(mnExit);

        jMenuBar1.add(mnFile);

        mnEdit.setText("Edit");

        mnSelectAll.setText("Select All");
        mnSelectAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnSelectAllActionPerformed(evt);
            }
        });
        mnEdit.add(mnSelectAll);
        mnEdit.add(jSeparator2);

        mnCut.setText("Cut");
        mnCut.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnCutActionPerformed(evt);
            }
        });
        mnEdit.add(mnCut);

        mnCopy.setText("Copy");
        mnCopy.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnCopyActionPerformed(evt);
            }
        });
        mnEdit.add(mnCopy);

        mnPaste.setText("Paste");
        mnPaste.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnPasteActionPerformed(evt);
            }
        });
        mnEdit.add(mnPaste);
        mnEdit.add(jSeparator3);

        mnUndo.setText("Undo");
        mnUndo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnUndoActionPerformed(evt);
            }
        });
        mnEdit.add(mnUndo);

        mnRedo.setText("Redo");
        mnRedo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnRedoActionPerformed(evt);
            }
        });
        mnEdit.add(mnRedo);
        mnEdit.add(jSeparator4);

        mnFind.setText("Find");
        mnFind.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnFindActionPerformed(evt);
            }
        });
        mnEdit.add(mnFind);

        mnReplace.setText("Replace");
        mnReplace.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnReplaceActionPerformed(evt);
            }
        });
        mnEdit.add(mnReplace);

        mnFont.setText("Change Font");
        mnFont.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnFontActionPerformed(evt);
            }
        });
        mnEdit.add(mnFont);

        jMenuBar1.add(mnEdit);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 650, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 429, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void mnExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnExitActionPerformed
        // Khi bấm Exit phải hỏi user muốn lưu bài hay ko
        if (txtContent.getText().isEmpty()) // Text rỗng, chưa nhập nd hoặc đã xoá hết nd
            System.exit(0);     // Tắt luôn, khỏi Save
        else                    // Tôi thấy có vấn đề chỗ đã xoá hết nd á. Cũng phải lưu chứ nhỉ?
        {
            confirmSaving(evt); // Lưu rồi mới save     // Sửa chỗ này. Thêm No và Cancel
            System.exit(0);
        }
    }//GEN-LAST:event_mnExitActionPerformed

    private void mnFindActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnFindActionPerformed
        // updateBtnStatus();
        // Các xử lý nằm bên Finđialog
        FindDialog dlg = new FindDialog(this, true);
        dlg.setVisible(true);
    }//GEN-LAST:event_mnFindActionPerformed

    private void mnFontActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnFontActionPerformed
        // Dùng JFontChooser đề cho sẵn
        Font f = JFontChooser.showDialog(this);
        txtContent.setFont(f);
//        mnSaveActionPerformed(evt);
//        memory = txtContent.getText();  // Ko biết đổi font mà ko đổi nd thì có cập nhật đc memory ko nhỉ?
                                          // Chắc là ko...
    }//GEN-LAST:event_mnFontActionPerformed

    private void mnUndoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnUndoActionPerformed
        // Dùng thư viện:
        try
        {
            manager.undo();
        } catch (CannotUndoException e) {
            JOptionPane.showMessageDialog(null, "Cannot undo.");
        }
        updateUndoRedoBtn();
//        memory = txtContent.getText();
//        mnSaveActionPerformed(evt);
        // Tôi thấy hơi sai sai đó... Cứ cập nhật liên tục thế này thì sao mà checkChange() để save đc?! .-.
    }//GEN-LAST:event_mnUndoActionPerformed

    private void mnOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnOpenActionPerformed
    // Mở file tức là đọc nội dung trong file đc chọn (file sẵn trong máy) và ghi lên màn hình Notepad
    // Chỉ đọc file .txt vì Notepad thật nó vậy
    
    // Trước khi mở file phải hỏi user có muốn lưu file hiện hành ko
//        confirmSaving(evt);   // Cái này ko xử lý đc NO_OPTION vs CANCEL_OPTION nên tôi phải viết riêng trong này
        if (checkChange() == true)
        {
            int save = JOptionPane.showConfirmDialog(this, "Do you want to save current changes?");
            if (save == JOptionPane.YES_OPTION)
            {
                mnSaveActionPerformed(evt);     // Save rồi mới Open
                openFile();
            }
            else if (save == JOptionPane.NO_OPTION)
            {   // Có cách nào để ko dán đoạn này 2 lần ko?
                openFile();
            }
            // Vì để xử lý đc cái nút CANCEL_OPTION cho nó ko làm gì cả thì phải làm kiểu này! .-.
        }
        else
            openFile();     // Chỉ vì 1 nút Cancel thôi mà phiền thật! .-.
    }//GEN-LAST:event_mnOpenActionPerformed

    private void mnSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnSaveActionPerformed
        if (!txtContent.getText().equals(""))
        {
            // updateBtnStatus();
            // Lưu file tức là ghi toàn bộ nội dung trên màn hình Notepad xuống file
            // Nếu lưu lần đầu thì cho user tạo file mới (gọi SaveAs), còn ko thì lưu vào file hiện hành
            // Chỉ đọc file .txt vì Notepad thật nó vậy
            if (this.getTitle().length() <= 0)   // Chưa lưu lần nào
            {
                mnSaveAsActionPerformed(evt);   // Mở hộp thoại, lưu file mới như trong SaveAs
                memory = txtContent.getText();  // Cập nhật memory
            }
            else    // Cập nhật vào file hiện tại
            {
                if(oldFile != null)     // Đã có file hiện tại (có tên trên title)
                {
                    writeFile(oldFile);     // Ghi đè lên file hiện hành
                    memory = txtContent.getText();  // Cập nhật memory
                }
            }
        }    
        else    
            JOptionPane.showMessageDialog(null, "The text has no content to save.");
            // Mỗi 1 cái if...else bắt lỗi này thay cho cái đống updateBtnStatus() á!
    }//GEN-LAST:event_mnSaveActionPerformed

    private void mnSaveAsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnSaveAsActionPerformed
        if (!txtContent.getText().equals(""))
        {
            // updateBtnStatus();
            // Lưu file tức là ghi toàn bộ nội dung trên màn hình Notepad xuống file
            // Nếu lưu lần đầu thì cho user tạo file mới (gọi SaveAs), còn ko thì lưu vào file hiện hành
            // Chỉ đọc file .txt vì Notepad thật nó vậy (và đề cũng chỉ yêu cầu vậy)
            int save = fc.showSaveDialog(this);
//            fc.setDialogTitle("Save As");
//            fc.setFileFilter(new FileTypeFilter(".txt", "Text File"));  // Để trên constructor rồi
            if (save == JFileChooser.APPROVE_OPTION)    // Bấm nút "Save"
            {   // Tôi nghĩ là cái fileName này chính là cái ô hiện tên á! @@ Khá là ảo diệu!
                String fileName = fc.getSelectedFile().getName();
                if (!fileName.endsWith(".txt"))    // Nếu tên nhập vào chưa có đuôi thì mình add thêm đuôi
                    fileName += ".txt";
                
                File saveFile = new File(fc.getCurrentDirectory()+"\\"+fileName);
                // Ảo diệu ha! :))))    // Ý!!! Bị hố rồi! :))) 2 cái này là 1 mà! :)))
                // if (fileName.equals(fc.getSelectedFile().getName())
                if (saveFile.exists())  // Tên file đã tồn tại
                {
                    int replaceOrNot = JOptionPane.showConfirmDialog(this, fileName + " already existed. \n" + 
                                                        "Do you want to replace it?");
//                    if (replaceOrNot == JOptionPane.YES_OPTION)
//                        break;    // Nhớ có while thì mới break đc!
                }
                // Nếu xử lý đc cái trên thì lôi cái này lên trên
                writeFile(new File(fc.getCurrentDirectory()+"\\"+fileName));    // Ghi file mới
                // Mục đích của việc có cái getCurrentDirectory() này là để cho lưu ở thư mục nào cũng đc
                // chứ ko nhất thiết chỉ trong thư mục project của mình
                this.setTitle(fileName);
                memory = txtContent.getText();  // Cập nhật memory
            }
        }    
        else    
            JOptionPane.showMessageDialog(null, "The text has no content to save.");
    }//GEN-LAST:event_mnSaveAsActionPerformed

    private void mnRedoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnRedoActionPerformed
        // Cách dùng thư viện:
        try
        {
            manager.redo();
        } catch (CannotRedoException e) {
            JOptionPane.showMessageDialog(null, "Cannot redo.");
        }
        updateUndoRedoBtn();
//        memory = txtContent.getText();
//        mnSaveActionPerformed(evt);
    }//GEN-LAST:event_mnRedoActionPerformed

    private void mnReplaceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnReplaceActionPerformed
        // updateBtnStatus();
        // Các xử lý nằm bên ReplaceDialog
        ReplaceDialog dlg = new ReplaceDialog(this, true);
        dlg.setVisible(true);
//        mnSaveActionPerformed(evt);     // Save mỗi thay đổi bên ReplaceDialog
//        memory = txtContent.getText();  // Ko biết có nên cập nhật memory trong ReplaceDialog hay ở đây nữa! .-.
    }//GEN-LAST:event_mnReplaceActionPerformed

    private void mnNewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnNewActionPerformed
        // Nội dung != empty mà chưa lưu thì phải hỏi user có muốn save trước khi New hay ko
//        confirmSaving(evt); // Ko xử lý đc tr.h chọn Cancel hoặc ko chọn vì mỗi btn 1 việc khác nhau
        if (checkChange() == true)
        {
            int save = JOptionPane.showConfirmDialog(this, "Do you want to save current changes?");
            if (save == JOptionPane.YES_OPTION)
            {
                mnSaveActionPerformed(evt);     // Validate tr.h khi bấm nút X góc trái trên
                txtContent.setText("");
                this.setTitle("");
                memory = txtContent.getText();  // Hoặc cũng có thể ghi là memory = "";
            }   // Cập nhật memory
            else if (save == JOptionPane.NO_OPTION)
            {
                txtContent.setText("");         // New luôn, khỏi Save
                this.setTitle("");
                memory = txtContent.getText();  // Cập nhật memory
            }   // Ko cần CANCEL_OPTION vì mình ko viết code cho nó thì nó cũng tự dispose luôn rồi
        }
        else    // Nếu nd ko thay đổi so vs lúc mới mở lên ban đầu (bao gồm cả tr.h trang trắng chưa viết chữ)
        {
            txtContent.setText("");         // New luôn, khỏi Save
            this.setTitle("");
            memory = "";  // Cập nhật memory
        }
    }//GEN-LAST:event_mnNewActionPerformed

    private void mnSelectAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnSelectAllActionPerformed
        if (!txtContent.getText().equals(""))
        {
            // updateBtnStatus();
            txtContent.selectAll();
//            memory = txtContent.getText();  // Cái này ở đây có cần thiết ko nhỉ? .-.
        }    
        else    
            JOptionPane.showMessageDialog(null, "The text has no content to select.");
    }//GEN-LAST:event_mnSelectAllActionPerformed

    private void mnCutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnCutActionPerformed
        if (!txtContent.getText().equals(""))
        {
            // updateBtnStatus();
            txtContent.cut();
//            memory = txtContent.getText();
//            mnSaveActionPerformed(evt);  // Cái này ở đây có cần thiết ko nhỉ? .-. Thấy hơi kì!
        }    
        else    
            JOptionPane.showMessageDialog(null, "The text has no content to cut.");
    }//GEN-LAST:event_mnCutActionPerformed

    private void mnCopyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnCopyActionPerformed
        if (!txtContent.getText().equals(""))
        {
            // updateBtnStatus();
            txtContent.copy();
//            memory = txtContent.getText();  // Cái này để đây thì có ý nghĩa gì?
        }    
        else    
            JOptionPane.showMessageDialog(null, "The text has no content to copy.");
    }//GEN-LAST:event_mnCopyActionPerformed

    private void mnPasteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnPasteActionPerformed
//        if (!txtContent.getText().equals(""))     // Ai cấm paste khi chưa có gì đâu nhỉ?! .-.
//        {
            // updateBtnStatus();
            txtContent.paste();     // Cho paste thoải mái! Đâu cứ phải copy/cut trong txt thì mới paste đc!
//            memory = txtContent.getText();
//            mnSaveActionPerformed(evt);  // Cái này ở đây có cần thiết ko nhỉ? .-. Thấy hơi kì!
//        }    
//        else    
//            JOptionPane.showMessageDialog(null, "The text has no content to paste.");
    }//GEN-LAST:event_mnPasteActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        mnExitActionPerformed(null);
    }//GEN-LAST:event_formWindowClosing

    private boolean checkChange()
    {
        if (memory.equals(txtContent.getText()))    // Nd mới (getText()) giống nd cũ (memory)
            return false;   // Ko thay đổi
        
        return true;
    }
    
    // Đang xem xét bỏ cái này
    private void confirmSaving(java.awt.event.ActionEvent evt)
    {
        if (checkChange() == true)
        {
            int save = JOptionPane.showConfirmDialog(this, "Do you want to save current changes?");
            if (save == JOptionPane.YES_OPTION)
                mnSaveActionPerformed(evt);
//            else if (save == JOptionPane.CANCEL_OPTION)
//                this.dispose();   // Ở đây nó hiểu "this" là cái frame Notepad luôn! ._.
        }   // Phải tách thôi! .-.
    }
    
    private void writeFile(File f)  // Sửa lại là 1 file luôn chứ ko chỉ là String fileName ko thôi nữa!
    {
//        File f = new File(fileName);    // Tạo mới 1 file
        PrintWriter pw = null;
        try
        {
            pw = new PrintWriter(f);
            pw.write(txtContent.getText());
            // PrintWriter chỉ cần write() là đc, nó tự flush() cho mình còn FileWriter phải gọi flush() bằng tay
        } catch (FileNotFoundException ex) {
//            System.out.println("Error write file: " + ex.getMessage());
            JOptionPane.showMessageDialog(null, "File not found.");
        } finally
        {
            if (pw != null)
                pw.close();
        }
    }
    
    private void readFile(File f)  // Sửa lại là 1 file luôn chứ ko chỉ là String fileName ko thôi nữa!
    {   // Tại sao chỉ đọc và ghi đc file trong thư mục project của mình còn ở chỗ khác đều báo File not Found???
//        File f = new File(fileName);  // Tạo 1 file f là file vừa đc chọn   // --> Khỏi, truyền file vào luôn
        FileReader fr = null;     // FileReader chỉ đọc đc kí tự thường, giờ tôi muốn nó đọc đc cả các kí tự
//        FileInputStream is = null;  // đặc biệt (chữ tiếng Nhật, t.Việt) nữa nên phải dùng cái InputStream này.
//        InputStreamReader ir = null;
        BufferedReader br = null;
        try
        {
            fr = new FileReader(f);
//            is = new FileInputStream(f);
//            ir = new InputStreamReader(is, "Unicode"); // Đọc các kí tự Unicode (16-bit)
//            br = new BufferedReader(ir);
            br = new BufferedReader(fr);
            while (br.ready())  // "br.ready()" hay "!br.ready()"?
            {
//                    String s = br.readLine();
                String s;   // Ko cần phải viết 2 dòng giống nhau như vậy (2 dòng bị cmt lại)
                while((s = br.readLine()) != null)  // Làm thế này luôn cho gọn
                {   // Đọc từng dòng trong file rồi ghi từng dòng đã đọc đc vào Notepad
                    txtContent.append(s + "\n");
//                        s = br.readLine();
                }
            }
            this.setTitle(fc.getSelectedFile().getName());  // Cái này để phân biệt 2 trạng thái đã-chưa lưu
            oldFile = f;    // Cái title là của oldFile. Cập nhật oldFile là file vừa ghi.
        }
        catch (FileNotFoundException ex)
        {
//            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "File not found.");
            this.setTitle("");
        }
        catch (IOException ex)
        {
            JOptionPane.showMessageDialog(null, "Read file failed. Invalid file's type.");
        }
        finally
        {
            try
            {
                if (br != null)
                    br.close();
                if (fr != null)
                    fr.close();
//                if (ir != null)
//                    ir.close();
//                if (is != null)
//                    is.close();
            } catch (IOException ex) {
                System.out.println("Cannot close.");
//                ex.printStackTrace();
            }
        }
    }
    
    private void openFile()
    {
        int open = fc.showOpenDialog(this);
//        fc.setDialogTitle("Open");    // Nó cứ bị nhảy tùm lum giữa "Open" vs "Save As" nên bỏ đi cho đỡ sai
//        fc.setFileFilter(null);   // Tại sao mỗi lần bấm Open là nó lại add thêm 1 dòng "Text File (*.txt)"?
//        fc.setFileFilter(new FileTypeFilter(".txt", "Text File"));  // -> Để 1 lần duy nhất trên constructor
        
        try
        {
            File saveFile = new File(fc.getCurrentDirectory()+"\\"+fc.getSelectedFile().getName());
            if (open == JFileChooser.APPROVE_OPTION)    // User đã chọn file thành công (đã bấm nút "Open")
            {
                if(saveFile.exists())   // Có file này trong thư mục
                {
                    txtContent.setText(""); // Trước khi ghi file thì txt phải trống  // Thật ra dòng này hơi thừa! .-.
                    readFile(saveFile);
                    memory = txtContent.getText();  // Cập nhật memory
                }
                else    // Tên file ko khớp vs bất kì file nào cả. File chưa tồn tại!
                    JOptionPane.showMessageDialog(null, "File did not exist.");
            }
        }
        catch(Exception e) {}   // Lỗi này ko cần báo. Nó là cái mở hộp thoại mà ko chọn file thôi!
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MyTextEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MyTextEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MyTextEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MyTextEditor.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MyTextEditor().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    private javax.swing.JPopupMenu.Separator jSeparator3;
    private javax.swing.JPopupMenu.Separator jSeparator4;
    private javax.swing.JMenuItem mnCopy;
    private javax.swing.JMenuItem mnCut;
    private javax.swing.JMenu mnEdit;
    private javax.swing.JMenuItem mnExit;
    private javax.swing.JMenu mnFile;
    private javax.swing.JMenuItem mnFind;
    private javax.swing.JMenuItem mnFont;
    private javax.swing.JMenuItem mnNew;
    private javax.swing.JMenuItem mnOpen;
    private javax.swing.JMenuItem mnPaste;
    private javax.swing.JMenuItem mnRedo;
    private javax.swing.JMenuItem mnReplace;
    private javax.swing.JMenuItem mnSave;
    private javax.swing.JMenuItem mnSaveAs;
    private javax.swing.JMenuItem mnSelectAll;
    private javax.swing.JMenuItem mnUndo;
    javax.swing.JTextArea txtContent;
    // End of variables declaration//GEN-END:variables
}

// Lỗi:
// 1. Tại sao chỉ đọc và ghi đc file trong thư mục project của mình còn ở chỗ khác đều báo File not Found???
// 2. Chưa validate đc nếu lưu trùng tên file thì phải hỏi có muốn replace ko (do chưa lấy đc ô tên file đó).
//    Nó đang gặp 1 vấn đề là tên nào cũng trùng, dù trước đó chưa có...
// => Check đc rồi. Mai thêm cái vòng while vào nữa vs thêm mấy cái tr.h xử lý Yes_No! 'v'
// 3. Nếu nhập xong mà bấm New vs Open thì vẫn hỏi muốn lưu ko bình thường nhưng nếu vòng qua bấm Save trước
//    nhưng ko lưu mà tắt đi, xong mới vòng lại hộp thoại New / Open thì lại ko hỏi muốn lưu hay ko nữa! .-.